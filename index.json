[{"content":" ","date":"2024年11月18日","externalUrl":null,"permalink":"/","section":"","summary":" ","title":"","type":"page"},{"content":" 算了 不在折腾了，以后就用这个吧 2024年11月18日 · 01:02\n","date":"2024年11月18日","externalUrl":null,"permalink":"/shuoshuo-single/4/","section":"Shuoshuo-Singles","summary":"","title":"","type":"shuoshuo-single"},{"content":"","date":"2024年11月18日","externalUrl":null,"permalink":"/shuoshuo-single/","section":"Shuoshuo-Singles","summary":"","title":"Shuoshuo-Singles","type":"shuoshuo-single"},{"content":"日志\n","date":"2024年11月13日","externalUrl":null,"permalink":"/posts/","section":"","summary":"","title":"","type":"posts"},{"content":"","date":"2024年11月13日","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","date":"2024年11月13日","externalUrl":null,"permalink":"/authors/foraeu/","section":"Authors","summary":"","title":"Foraeu","type":"authors"},{"content":"","date":"2024年11月13日","externalUrl":null,"permalink":"/tags/numpy/","section":"Tags","summary":"","title":"Numpy","type":"tags"},{"content":"","date":"2024年11月13日","externalUrl":null,"permalink":"/tags/python/","section":"Tags","summary":"","title":"Python","type":"tags"},{"content":"","date":"2024年11月13日","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2024年11月13日","externalUrl":null,"permalink":"/tags/%E7%9F%A9%E9%98%B5%E5%90%88%E5%B9%B6/","section":"Tags","summary":"","title":"矩阵合并","type":"tags"},{"content":"在处理数据时，有时需要多次按行合并矩阵。本文将探讨两种不同的矩阵合并方式，并分析哪种方法更高效。\n问题是这样的：有1个矩阵，假设其shape为m*n。现在希望对于某一行l1，将其它的行依次添加到该行的后部，但由于列数限制为2n，需要生成m行，每行分别为[l1,l2],[l1,l3],……,[l1,lm]。将这种处理作用于所有的行，最终能够得到一个(m-1)*m行，2n列的矩阵。\n方法一\n创建一个列数为2n的空矩阵matrix_end，在循环中，先依次对原矩阵每一行生成m-1行，2n列的矩阵，每行分别为[li,l1],[li,l2],……,[li,lm]，然后将该矩阵与matrix_end合并。实现如下：\nimport numpy as np import time # 设置随机种子 np.random.seed(0) # 记录运行时间 start = time.time() # 随机生成1000行5列的矩阵init_matrix init_matrix = np.random.randint(0, 10, size=(1000, 5)) matrix_end = np.empty((0, init_matrix.shape[1]*2)) # 逐行合并 for idx in range(init_matrix.shape[0]): neighbor_rows = np.delete(init_matrix, idx, axis=0) row = np.concatenate([init_matrix[idx] + 0 * neighbor_rows, neighbor_rows], axis=1) matrix_end = np.concatenate([matrix_end, row], axis=0) end = time.time() print(\u0026#34;Time:\u0026#34;, end - start) 最终的运行时间为7.4s\n方法二\n创建一个空列表，在循环中，先得到m-1行，2n列的矩阵，将结果存储到列表中，之后在循环外一次性将所有行合并成一个矩阵。实现如下：\nimport numpy as np import time # 设置随机种子 np.random.seed(0) # 记录运行时间 start = time.time() # 随机生成1000行5列的矩阵init_matrix init_matrix = np.random.randint(0, 10, size=(1000, 5)) matrix_list = [] for idx in range(init_matrix.shape[0]): neighbor_rows = np.delete(init_matrix, idx, axis=0) row = np.concatenate([init_matrix[idx] + 0 * neighbor_rows, neighbor_rows], axis=1) matrix_list.append(row) # 一次性合并所有行 matrix = np.vstack(matrix_list) end = time.time() print(\u0026#34;Time:\u0026#34;, end - start) 最终的运行时间为0.05s\n为何性能相差如此之大？\n对于方法一，由于每次调用np.concatenate都会创建一个新的数组，所有的数据（原矩阵 + 新增的行）会被复制到新的数组中，内存需要重新分配。随着矩阵行数的增加，每次合并时的内存重新分配和数据复制的开销也会随之增加，导致性能下降。\n对于方法二，首先是使用matrix_list.append(row)将每一行的数据先存储在一个列表中，列表操作是非常高效的，因为它只是将数据引用添加到内存中，而不需要重新分配内存或复制数据。其次是最后通过np.vstack(matrix_list)一次性将所有的行合并成一个新的矩阵，np.vstack会一次性计算最终矩阵的大小并分配内存，然后将所有的行合并到一起。这比逐行合并要高效得多。\n在常规观念里，使用numpy进行操作往往比python自带的list,dict更加高效。在这个例子里，我们也看到了list数据结构的优势。虽然numpy在处理大规模矩阵和向量运算时有显著的性能优势，因为它是基于底层的C语言实现，并且能够通过向量化操作减少循环的开销，但在某些情况下，使用python的list可以在内存管理和操作的灵活性上带来额外的好处。\n在我们讨论的优化过程中，使用list来积累行数据比每次都通过np.concatenate合并矩阵要更加高效。Python列表的内存管理是动态的，NumPy数组的内存管理是静态的，数组的大小在创建时就已经确定。list的append()操作是一个时间复杂度为 O(1) 的常数时间原位操作，意味着它的开销非常小。而np.concatenate是非原位操作，每次合并矩阵时，都会导致内存重新分配和数据复制，这种操作的时间复杂度是 O(N)，尤其是在需要反复进行矩阵拼接时，矩阵也会增大，性能下降非常明显。\n因此，在需要多次进行矩阵合并或行拼接时，先将结果存储在list中，再使用numpy的批量合并操作（如np.vstack或np.concatenate）来一次性合并，这种方法能够显著提高性能，减少不必要的内存操作和数据复制。\n","date":"2024年11月13日","externalUrl":null,"permalink":"/posts/3/","section":"","summary":"","title":"矩阵合并的优化","type":"posts"},{"content":"","date":"2024年11月7日","externalUrl":null,"permalink":"/tags/%E6%89%93%E6%B2%B9%E8%AF%97/","section":"Tags","summary":"","title":"打油诗","type":"tags"},{"content":"无题 露湿花重晓天白，晨起事无门户开。\n东风携来远方信，吹乱衣襟不忍拆。\n","date":"2024年11月7日","externalUrl":null,"permalink":"/posts/2/","section":"","summary":"","title":"一首小诗","type":"posts"},{"content":" 关于背景选择 dark可以保留更多的细节，给人新鲜的感觉，但light相对简约厚重，似乎更适合长时间使用 2024年11月06日 · 14:46\n","date":"2024年11月6日","externalUrl":null,"permalink":"/shuoshuo-single/3/","section":"Shuoshuo-Singles","summary":"","title":"","type":"shuoshuo-single"},{"content":"","date":"2024年10月30日","externalUrl":null,"permalink":"/tags/%E8%B7%9D%E7%A6%BB%E8%AE%A1%E7%AE%97/","section":"Tags","summary":"","title":"距离计算","type":"tags"},{"content":" 前言 # 在处理包含地理坐标的数据时，常常涉及到计算两个或多个坐标之间的欧式距离。当处理大量的数据点时，计算两两之间的距离会变得非常耗时，因为随着数据点的增加，组合的数量呈二次方增长。在python中，除了常规的for循环，还有哪些方法能够更高效地计算距离呢\n坐标距离计算方法 # 1. NumPy的向量化 # NumPy是一个高效的数值计算库，提供了向量化操作的能力，可以避免使用循环。通过将数据组织为数组，我们可以一次性计算多个距离。\n示例代码\nimport numpy as np def calculate_distances(coords1, coords2): # 将坐标转换为NumPy数组 coords1 = np.array(coords1) coords2 = np.array(coords2) # 计算两两之间的距离 dists = np.sqrt(np.sum((coords1[:, np.newaxis] - coords2) ** 2, axis=2)) return dists # 测试数据 coords1 = [(0, 0), (1, 1), (2, 2)] coords2 = [(1, 0), (2, 1)] distances = calculate_distances(coords1, coords2) print(distances) 核心思想\nNumPy的向量化使我们能够利用底层的C语言实现来加速计算，而无需显式地编写循环。通过扩展数组的维度，我们能够在单次操作中计算多个距离，显著提高了性能。\n2. KD树 # KD树是一种空间分割的数据结构，可以快速地找到最近邻。对于大规模的点集合，KD树能够大幅度减少计算的复杂度。\n示例代码\nfrom scipy.spatial import KDTree def find_nearest(coords, target): tree = KDTree(coords) distances, indices = tree.query(target) return distances, indices # 测试数据 coords = [(0, 0), (1, 1), (2, 2), (3, 3)] target = (1.5, 1.5) distances, indices = find_nearest(coords, target) print(f\u0026#34;Nearest point index: {indices}, Distance: {distances}\u0026#34;) 核心思想\nKD树通过空间划分，将数据组织成树状结构，使得在高维空间中查找最近邻变得更加高效，避免了遍历所有点的必要性。\n3. 数据分块 # 当数据集过大时，可以考虑将数据分块处理。通过将数据划分为小块，我们可以在每次计算时只处理一部分数据，从而降低内存使用和提高速度。\n示例代码\ndef chunked_distances(coords1, coords2, chunk_size): dists = [] for i in range(0, len(coords1), chunk_size): chunk = coords1[i:i + chunk_size] dists.append(calculate_distances(chunk, coords2)) return np.concatenate(dists) # 测试数据 chunked_dists = chunked_distances(coords1, coords2, chunk_size=2) print(chunked_dists) 核心思想\n数据分块允许我们在内存有限的情况下处理大规模数据集，分块计算可以减少对内存的压力，同时保持计算的灵活性。\n4. 使用Cython或Numba # Cython和Numba都是用于加速Python代码的工具。Cython通过将Python代码编译为C代码来加速计算，而Numba则通过即时编译（JIT）优化数值计算。\n示例代码\nfrom numba import jit @jit(nopython=True) def fast_calculate_distances(coords1, coords2): dists = np.zeros((len(coords1), len(coords2))) for i in range(len(coords1)): for j in range(len(coords2)): dists[i, j] = np.sqrt((coords1[i, 0] - coords2[j, 0]) ** 2 + (coords1[i, 1] - coords2[j, 1]) ** 2) return dists # 测试数据 coords1 = np.array([(0, 0), (1, 1), (2, 2)]) coords2 = np.array([(1, 0), (2, 1)]) distances = fast_calculate_distances(coords1, coords2) print(distances) 核心思想\n通过使用Cython或Numba，可以将Python的动态特性转化为静态类型，从而极大地提高计算速度，尤其是在进行大量重复计算时。\n","date":"2024年10月30日","externalUrl":null,"permalink":"/posts/1/","section":"","summary":"","title":"距离计算的优化方法","type":"posts"},{"content":" 终于 网页算是初步建好了，回归正常生活了 2024年10月28日 · 02:53\n","date":"2024年10月28日","externalUrl":null,"permalink":"/shuoshuo-single/2/","section":"Shuoshuo-Singles","summary":"","title":"","type":"shuoshuo-single"},{"content":" 更新 什么时候能把这个`{{hugo_ctx/}}这个错误弄好😫 2024年10月26日 · 02:01\n","date":"2024年10月26日","externalUrl":null,"permalink":"/shuoshuo-single/1/","section":"Shuoshuo-Singles","summary":"","title":"","type":"shuoshuo-single"},{"content":" Hello World 🌍 # 欢迎来到我的第一篇博客！🎉\n简介 # 本人的第一篇博客 网站基于 Github Pages + Hugo 搭建 主题为Blowfish 建站时间 # 📅 2024-10-24\n期待 # 希望以后能坚持更新，写一些有意义的博客。✍️\n感想 # 虽然花了很多时间，但感觉搭建的过程很有趣 😊，不枉我的一番胡乱折腾。\n参考 # 网站图标：Numpy 的图标 Icons8\n标签页面：ZhenShuo2021\n悬浮播放器，说说：金圣皓\n评论系统：utterances\n主页诗词调用：今日诗词 API\n","date":"2024年10月26日","externalUrl":null,"permalink":"/posts/0/","section":"","summary":"","title":"Hello World","type":"posts"},{"content":"","date":"2024年10月26日","externalUrl":null,"permalink":"/tags/%E7%AC%AC%E4%B8%80%E7%AF%87/","section":"Tags","summary":"","title":"第一篇","type":"tags"},{"content":" ","externalUrl":null,"permalink":"/about/","section":"","summary":"","title":"","type":"page"},{"content":" 更新 什么时候能把这个`{{hugo_ctx/}}这个错误弄好😫 2024年10月26日 · 02:01\n终于 网页算是初步建好了，回归正常生活了 2024年10月28日 · 02:53\n关于背景选择 dark可以保留更多的细节，给人新鲜的感觉，但light相对简约厚重，似乎更适合长时间使用 2024年11月06日 · 14:46\n算了 不在折腾了，以后就用这个吧 2024年11月18日 · 01:02\n","externalUrl":null,"permalink":"/shuoshuo/","section":"","summary":"","title":"","type":"page"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]